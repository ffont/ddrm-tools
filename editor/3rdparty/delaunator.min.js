!function (t, i) { "object" == typeof exports && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : t.Delaunator = i() }(this, function () { "use strict"; var t = Math.pow(2, -52), i = function (i) { var n = 1 / 0, l = 1 / 0, o = -1 / 0, f = -1 / 0, u = i.length >> 1, v = this.ids = new Uint32Array(u); if (u > 0 && "number" != typeof i[0]) throw new Error("Expected coords to contain numbers."); this.coords = i; for (var _ = 0; _ < u; _++) { var d = i[2 * _], g = i[2 * _ + 1]; d < n && (n = d), g < l && (l = g), d > o && (o = d), g > f && (f = g), v[_] = _ } for (var y, c, w, p = (n + o) / 2, b = (l + f) / 2, x = 1 / 0, z = 0; z < u; z++) { var S = r(p, b, i[2 * z], i[2 * z + 1]); S < x && (y = z, x = S) } var k = i[2 * y], A = i[2 * y + 1]; x = 1 / 0; for (var T = 0; T < u; T++)if (T !== y) { var M = r(k, A, i[2 * T], i[2 * T + 1]); M < x && M > 0 && (c = T, x = M) } for (var K = i[2 * c], m = i[2 * c + 1], U = 1 / 0, L = 0; L < u; L++)if (L !== y && L !== c) { var N = a(k, A, K, m, i[2 * L], i[2 * L + 1]); N < U && (w = L, U = N) } var E = i[2 * w], D = i[2 * w + 1]; if (U === 1 / 0) throw new Error("No Delaunay triangulation exists for this input."); if (h(k, A, K, m, E, D)) { var I = c, P = K, j = m; c = w, K = E, m = D, w = I, E = P, D = j } var q = function (t, i, r, h, a, s) { var e = r - t, n = h - i, l = a - t, o = s - i, f = e * e + n * n, u = l * l + o * o, v = e * o - n * l; return { x: t + .5 * (o * f - n * u) / v, y: i + .5 * (e * u - l * f) / v } }(k, A, K, m, E, D); this._cx = q.x, this._cy = q.y, function t(i, r, h, a, n, l) { var o, f, u; if (a - h <= 20) for (o = h + 1; o <= a; o++) { for (u = i[o], f = o - 1; f >= h && s(r, i[f], u, n, l) > 0;)i[f + 1] = i[f--]; i[f + 1] = u } else { var v = h + a >> 1; for (f = a, e(i, v, o = h + 1), s(r, i[h], i[a], n, l) > 0 && e(i, h, a), s(r, i[o], i[a], n, l) > 0 && e(i, o, a), s(r, i[h], i[o], n, l) > 0 && e(i, h, o), u = i[o]; ;) { do { o++ } while (s(r, i[o], u, n, l) < 0); do { f-- } while (s(r, i[f], u, n, l) > 0); if (f < o) break; e(i, o, f) } i[h + 1] = i[f], i[f] = u, a - o + 1 >= f - h ? (t(i, r, o, a, n, l), t(i, r, h, f - 1, n, l)) : (t(i, r, h, f - 1, n, l), t(i, r, o, a, n, l)) } }(v, i, 0, v.length - 1, q.x, q.y), this._hashSize = Math.ceil(Math.sqrt(u)), this._hash = new Int32Array(this._hashSize).fill(-1); var F = this.hullPrev = new Uint32Array(u), B = this.hullNext = new Uint32Array(u), C = this.hullTri = new Uint32Array(u); this.hullStart = y; var G = 3; B[y] = F[w] = c, B[c] = F[y] = w, B[w] = F[c] = y, C[y] = 0, C[c] = 1, C[w] = 2, this._hash[this._hashKey(k, A)] = y, this._hash[this._hashKey(K, m)] = c, this._hash[this._hashKey(E, D)] = w; var H = 2 * u - 5, J = this.triangles = new Uint32Array(3 * H), O = this.halfedges = new Int32Array(3 * H); this.trianglesLen = 0, this._addTriangle(y, c, w, -1, -1, -1); for (var Q = 0, R = void 0, V = void 0; Q < v.length; Q++) { var W = v[Q], X = i[2 * W], Y = i[2 * W + 1]; if (!(Q > 0 && Math.abs(X - R) <= t && Math.abs(Y - V) <= t) && (R = X, V = Y, W !== y && W !== c && W !== w)) { for (var Z = 0, $ = 0, tt = this._hashKey(X, Y); $ < this._hashSize && (-1 === (Z = this._hash[(tt + $) % this._hashSize]) || Z === B[Z]); $++); for (var it = Z = F[Z], rt = void 0; rt = B[it], !h(X, Y, i[2 * it], i[2 * it + 1], i[2 * rt], i[2 * rt + 1]);)if ((it = rt) === Z) { it = -1; break } if (-1 !== it) { var ht = this._addTriangle(it, W, B[it], -1, -1, C[it]); C[W] = this._legalize(ht + 2), C[it] = ht, G++; for (var at = B[it]; rt = B[at], h(X, Y, i[2 * at], i[2 * at + 1], i[2 * rt], i[2 * rt + 1]);)ht = this._addTriangle(at, W, rt, C[W], -1, C[at]), C[W] = this._legalize(ht + 2), B[at] = at, G-- , at = rt; if (it === Z) for (; h(X, Y, i[2 * (rt = F[it])], i[2 * rt + 1], i[2 * it], i[2 * it + 1]);)ht = this._addTriangle(rt, W, it, -1, C[it], C[rt]), this._legalize(ht + 2), C[rt] = ht, B[it] = it, G-- , it = rt; this.hullStart = F[W] = it, B[it] = F[at] = W, B[W] = at, this._hash[this._hashKey(X, Y)] = W, this._hash[this._hashKey(i[2 * it], i[2 * it + 1])] = it } } } this.hull = new Uint32Array(G); for (var st = 0, et = this.hullStart; st < G; st++)this.hull[st] = et, et = B[et]; this.hullPrev = this.hullNext = this.hullTri = null, this.triangles = J.subarray(0, this.trianglesLen), this.halfedges = O.subarray(0, this.trianglesLen) }; function r(t, i, r, h) { var a = t - r, s = i - h; return a * a + s * s } function h(t, i, r, h, a, s) { return (h - i) * (a - r) - (r - t) * (s - h) < 0 } function a(t, i, r, h, a, s) { var e = r - t, n = h - i, l = a - t, o = s - i, f = e * e + n * n, u = l * l + o * o, v = e * o - n * l, _ = .5 * (o * f - n * u) / v, d = .5 * (e * u - l * f) / v; return f && u && v && _ * _ + d * d || 1 / 0 } function s(t, i, h, a, s) { return r(t[2 * i], t[2 * i + 1], a, s) - r(t[2 * h], t[2 * h + 1], a, s) || t[2 * i] - t[2 * h] || t[2 * i + 1] - t[2 * h + 1] } function e(t, i, r) { var h = t[i]; t[i] = t[r], t[r] = h } function n(t) { return t[0] } function l(t) { return t[1] } return i.from = function (t, r, h) { r || (r = n), h || (h = l); for (var a = t.length, s = new Float64Array(2 * a), e = 0; e < a; e++) { var o = t[e]; s[2 * e] = r(o), s[2 * e + 1] = h(o) } return new i(s) }, i.prototype._hashKey = function (t, i) { return Math.floor((r = t - this._cx, h = i - this._cy, a = r / (Math.abs(r) + Math.abs(h)), (h > 0 ? 3 - a : 1 + a) / 4 * this._hashSize)) % this._hashSize; var r, h, a }, i.prototype._legalize = function (t) { var i = this.triangles, r = this.coords, h = this.halfedges, a = h[t], s = t - t % 3, e = a - a % 3, n = s + (t + 1) % 3, l = s + (t + 2) % 3, o = e + (a + 2) % 3; if (-1 === a) return l; var f, u, v, _, d, g, y, c, w, p, b, x, z, S, k, A, T = i[l], M = i[t], K = i[n], m = i[o]; if (f = r[2 * T], u = r[2 * T + 1], v = r[2 * M], _ = r[2 * M + 1], d = r[2 * K], g = r[2 * K + 1], y = r[2 * m], c = r[2 * m + 1], (w = f - y) * ((x = _ - c) * (A = (z = d - y) * z + (S = g - c) * S) - (k = (b = v - y) * b + x * x) * S) - (p = u - c) * (b * A - k * z) + (w * w + p * p) * (b * S - x * z) < 0) { i[t] = m, i[a] = T; var U = h[o]; if (-1 === U) { var L = this.hullStart; do { if (this.hullTri[L] === o) { this.hullTri[L] = t; break } L = this.hullNext[L] } while (L !== this.hullStart) } this._link(t, U), this._link(a, h[l]), this._link(l, o); var N = e + (a + 1) % 3; return this._legalize(t), this._legalize(N) } return l }, i.prototype._link = function (t, i) { this.halfedges[t] = i, -1 !== i && (this.halfedges[i] = t) }, i.prototype._addTriangle = function (t, i, r, h, a, s) { var e = this.trianglesLen; return this.triangles[e] = t, this.triangles[e + 1] = i, this.triangles[e + 2] = r, this._link(e, h), this._link(e + 1, a), this._link(e + 2, s), this.trianglesLen += 3, e }, i });